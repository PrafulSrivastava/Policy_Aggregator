# Story 8.5: API Rate Limiting & Security

## Status
Draft

## Story
**As a** developer,  
**I want** secure API access with proper rate limiting,  
**so that** I can protect the system from abuse while enabling integrations.

## Acceptance Criteria

1. Rate limiting implementation:
   - Rate limits per API key
   - Configurable limits (requests per minute/hour/day)
   - Different tiers (free, paid, enterprise)
2. Rate limit enforcement:
   - Track API usage per key
   - Enforce limits (return 429 Too Many Requests)
   - Rate limit headers in responses
3. API usage monitoring:
   - Track API calls per key
   - Usage statistics dashboard
   - Usage alerts (approaching limits)
4. API security:
   - HTTPS required for all API calls
   - API key rotation support
   - Key expiration (optional)
   - IP whitelisting (optional, enterprise)
5. Security best practices:
   - Input validation
   - SQL injection prevention
   - XSS prevention
   - CORS configuration
6. API billing integration:
   - Track usage for billing
   - Usage-based pricing (if applicable)
   - Usage reports
7. Security monitoring:
   - Log suspicious API activity
   - Alert on unusual patterns
   - Block malicious keys
8. Documentation:
   - Rate limit documentation
   - Security best practices guide
   - Troubleshooting guide

## Tasks / Subtasks

- [ ] Task 1: Create rate limiting service (AC: 1, 2)
  - [ ] Create `api/services/rate_limiter.py`
  - [ ] Implement rate limiting logic:
    - [ ] Track requests per API key
    - [ ] Use Redis or in-memory cache for tracking
    - [ ] Implement sliding window or token bucket algorithm
    - [ ] Check limits before processing request
    - [ ] Return 429 if limit exceeded
  - [ ] Support multiple time windows (per minute, per hour, per day)
- [ ] Task 2: Create rate limit configuration (AC: 1)
  - [ ] Create subscription tier model or configuration:
    - [ ] Free tier: 100 requests/hour
    - [ ] Paid tier: 1000 requests/hour
    - [ ] Enterprise tier: 10000 requests/hour (or unlimited)
  - [ ] Store tier limits in database or configuration
  - [ ] Associate API keys with subscription tiers
- [ ] Task 3: Implement rate limit middleware (AC: 2)
  - [ ] Create `api/middleware/rate_limit.py`
  - [ ] Create FastAPI dependency or middleware:
    - [ ] Extract API key from request
    - [ ] Check rate limits
    - [ ] Increment usage counter
    - [ ] Add rate limit headers to response
    - [ ] Return 429 if limit exceeded
  - [ ] Add headers: `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset`
- [ ] Task 4: Create API usage tracking (AC: 3)
  - [ ] Create Alembic migration for `api_usage` table:
    - [ ] `id`: UUID (primary key)
    - [ ] `api_key_id`: UUID (foreign key to api_keys)
    - [ ] `endpoint`: VARCHAR(255) (API endpoint called)
    - [ ] `method`: VARCHAR(10) (HTTP method)
    - [ ] `status_code`: INTEGER (HTTP status code)
    - [ ] `response_time_ms`: INTEGER (response time)
    - [ ] `ip_address`: VARCHAR(45) (client IP)
    - [ ] `created_at`: TIMESTAMP WITH TIME ZONE
  - [ ] Create SQLAlchemy model: `api/models/db/api_usage.py`
  - [ ] Log all API calls to database
- [ ] Task 5: Create usage monitoring dashboard (AC: 3)
  - [ ] Create `admin-ui/templates/pages/api/usage-monitoring.html` - Usage dashboard
  - [ ] Create web route: `GET /api/usage-monitoring`
  - [ ] Display usage statistics:
    - [ ] API calls per key (today, this week, this month)
    - [ ] Usage trends (chart)
    - [ ] Top endpoints
    - [ ] Usage alerts (approaching limits)
  - [ ] Add "API Usage Monitoring" link to admin navigation
- [ ] Task 6: Implement usage alerts (AC: 3)
  - [ ] Create alert system:
    - [ ] Check usage against limits
    - [ ] Alert when usage exceeds 80% of limit
    - [ ] Alert when usage exceeds 100% of limit
    - [ ] Send email alerts to API key owner
  - [ ] Create alert configuration (thresholds, recipients)
- [ ] Task 7: Implement API key rotation (AC: 4)
  - [ ] Add rotation functionality:
    - [ ] Generate new API key
    - [ ] Optionally revoke old key
    - [ ] Allow both keys active during transition period
  - [ ] Create `POST /api/api-keys/{id}/rotate` endpoint
  - [ ] Add rotation UI in admin interface
- [ ] Task 8: Implement API key expiration (AC: 4)
  - [ ] Add expiration support:
    - [ ] Set expiration date when creating key
    - [ ] Check expiration on authentication
    - [ ] Reject expired keys
    - [ ] Alert before expiration (optional)
  - [ ] Update API key model with expiration
- [ ] Task 9: Implement IP whitelisting (AC: 4)
  - [ ] Create Alembic migration for `api_key_ip_whitelist` table:
    - [ ] `id`: UUID (primary key)
    - [ ] `api_key_id`: UUID (foreign key)
    - [ ] `ip_address`: VARCHAR(45) (CIDR format supported)
    - [ ] `created_at`: TIMESTAMP WITH TIME ZONE
  - [ ] Add IP whitelist check in authentication:
    - [ ] If whitelist exists, check client IP
    - [ ] Reject if IP not whitelisted
  - [ ] Create API endpoints for managing IP whitelist
- [ ] Task 10: Implement input validation (AC: 5)
  - [ ] Use Pydantic models for request validation:
    - [ ] Validate all input parameters
    - [ ] Reject invalid input with 400 Bad Request
  - [ ] Add validation for:
    - [ ] Query parameters (pagination, filtering)
    - [ ] Path parameters (UUIDs, IDs)
    - [ ] Request body (if applicable)
- [ ] Task 11: Implement SQL injection prevention (AC: 5)
  - [ ] Use SQLAlchemy parameterized queries (already done)
  - [ ] Never use string formatting for SQL queries
  - [ ] Validate and sanitize all user input
  - [ ] Use ORM methods instead of raw SQL
- [ ] Task 12: Implement XSS prevention (AC: 5)
  - [ ] Sanitize all user input
  - [ ] Use proper content types in API responses
  - [ ] Set security headers (Content-Security-Policy)
  - [ ] Validate and escape output (if applicable)
- [ ] Task 13: Configure CORS (AC: 5)
  - [ ] Update FastAPI CORS configuration:
    - [ ] Allow specific origins only (not *)
    - [ ] Configure allowed methods
    - [ ] Configure allowed headers
    - [ ] Configure credentials handling
  - [ ] Make CORS configurable via environment variables
- [ ] Task 14: Implement API billing integration (AC: 6)
  - [ ] Track usage for billing:
    - [ ] Aggregate usage per API key
    - [ ] Calculate costs based on usage
    - [ ] Generate usage reports
  - [ ] Create billing report generation
  - [ ] Integrate with billing system (if applicable)
- [ ] Task 15: Implement security monitoring (AC: 7)
  - [ ] Create security monitoring service:
    - [ ] Log suspicious activity (failed auth, rate limit violations)
    - [ ] Detect unusual patterns (sudden spike in requests)
    - [ ] Alert on security events
  - [ ] Create security dashboard:
    - [ ] Display security events
    - [ ] Show blocked keys
    - [ ] Show suspicious activity
- [ ] Task 16: Create security documentation (AC: 8)
  - [ ] Create `docs/api/rate-limiting.md` - Rate limit documentation
  - [ ] Create `docs/api/security.md` - Security best practices
  - [ ] Create `docs/api/troubleshooting.md` - Troubleshooting guide
  - [ ] Document rate limits per tier
  - [ ] Document security measures

## Dev Notes

### Previous Story Insights
- Story 8.2 created public API endpoints and basic rate limiting
- Story 1.5 created authentication system
- Story 1.4 created FastAPI application

### Rate Limiting
**Implementation Options:**
- Redis for distributed rate limiting (recommended for production)
- In-memory cache for single-instance (sufficient for MVP)
- Token bucket or sliding window algorithm

**Rate Limit Headers:**
- `X-RateLimit-Limit`: Maximum requests allowed
- `X-RateLimit-Remaining`: Remaining requests
- `X-RateLimit-Reset`: Time when limit resets (Unix timestamp)

### Security Best Practices
**Input Validation:**
- Use Pydantic models for validation
- FastAPI automatically validates requests
- Reject invalid input with 400 Bad Request

**SQL Injection Prevention:**
- SQLAlchemy uses parameterized queries
- Never use string formatting for SQL

**CORS Configuration:**
- Configure allowed origins
- Don't use wildcard (*) in production
- Configure allowed methods and headers

### File Locations
[Source: docs/architecture/unified-project-structure.md]

Files to create:
- `api/services/rate_limiter.py` - Rate limiting service
- `api/middleware/rate_limit.py` - Rate limit middleware
- `api/models/db/api_usage.py` - API usage tracking model
- `api/services/security_monitoring.py` - Security monitoring service
- `admin-ui/templates/pages/api/usage-monitoring.html` - Usage dashboard
- `docs/api/rate-limiting.md` - Rate limit documentation
- `docs/api/security.md` - Security documentation
- `alembic/versions/XXX_add_api_usage.py` - Migration
- `alembic/versions/XXX_add_api_key_ip_whitelist.py` - Migration

### Coding Standards
[Source: docs/architecture/coding-standards.md]

**Security:**
- Always validate input
- Use parameterized queries
- Sanitize output
- Log security events

### Testing Requirements
[Source: docs/architecture/testing-strategy.md]

**Security Tests:**
- Test rate limiting enforcement
- Test input validation
- Test SQL injection prevention
- Test authentication and authorization

## Testing

**Security Tests:**
- Test rate limiting enforcement
- Test input validation
- Test SQL injection prevention
- Test authentication
- Test IP whitelisting

**Integration Tests:**
- Test rate limit headers
- Test usage tracking
- Test security monitoring

**Manual Testing:**
- Test rate limits with API calls
- View usage monitoring dashboard
- Test API key rotation
- Test security alerts

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-27 | 1.0 | Initial story creation | Bob (Scrum Master) |

