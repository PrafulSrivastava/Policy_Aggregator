# Story 1.3: Core Data Model and Business Logic Layer

## Status
Ready for Review

## Story
**As a** developer,  
**I want** Python models and business logic for core entities,  
**so that** I have a clean abstraction layer for database operations and can implement versioning and hashing logic.

## Acceptance Criteria

1. SQLAlchemy models created for: Source, PolicyVersion, PolicyChange, RouteSubscription
2. Repository/service layer with methods for:
   - Source CRUD operations
   - PolicyVersion creation and retrieval (by source_id, by hash)
   - PolicyChange creation and retrieval (by source_id, by route)
   - RouteSubscription CRUD operations
3. Hashing utility function: SHA256 hash generation for policy content
4. Versioning logic: PolicyVersion records are immutable (never updated, only new versions created)
5. Helper functions for: finding latest PolicyVersion for a source, comparing hashes
6. Unit tests for models and business logic (hashing, versioning)
7. Data validation: ensure required fields, proper data types, constraints

## Tasks / Subtasks

- [x] Task 1: Create Pydantic schemas for request/response validation (AC: 1, 7)
  - [x] Create `api/models/schemas/__init__.py`
  - [x] Create `api/models/schemas/source.py` with SourceCreate, SourceUpdate, SourceResponse
  - [x] Create `api/models/schemas/policy_version.py` with PolicyVersionCreate, PolicyVersionResponse
  - [x] Create `api/models/schemas/policy_change.py` with PolicyChangeCreate, PolicyChangeResponse
  - [x] Create `api/models/schemas/route_subscription.py` with RouteSubscriptionCreate, RouteSubscriptionUpdate, RouteSubscriptionResponse
  - [x] Add validation rules (required fields, email format, country codes, etc.)
- [x] Task 2: Create hashing utility (AC: 3)
  - [x] Create `api/utils/hashing.py`
  - [x] Implement `generate_hash(content: str) -> str` function using SHA256
  - [x] Ensure hash is exactly 64 characters (hex)
  - [x] Add unit tests for hashing function
- [x] Task 3: Create Source repository (AC: 2)
  - [x] Create `api/repositories/source_repository.py`
  - [x] Implement `create(source_data: dict) -> Source`
  - [x] Implement `get_by_id(source_id: UUID) -> Optional[Source]`
  - [x] Implement `list_all() -> List[Source]`
  - [x] Implement `list_active() -> List[Source]`
  - [x] Implement `update(source_id: UUID, update_data: dict) -> Source`
  - [x] Implement `delete(source_id: UUID) -> bool`
  - [x] Implement `get_by_country_visa(country: str, visa_type: str) -> List[Source]`
- [x] Task 4: Create PolicyVersion repository (AC: 2, 4, 5)
  - [x] Create `api/repositories/policy_version_repository.py`
  - [x] Implement `create(version_data: dict) -> PolicyVersion`
  - [x] Implement `get_by_id(version_id: UUID) -> Optional[PolicyVersion]`
  - [x] Implement `get_by_source_id(source_id: UUID) -> List[PolicyVersion]`
  - [x] Implement `get_latest_by_source_id(source_id: UUID) -> Optional[PolicyVersion]`
  - [x] Implement `get_by_hash(content_hash: str) -> Optional[PolicyVersion]`
  - [x] Implement `exists_by_hash(source_id: UUID, content_hash: str) -> bool` (for idempotency)
  - [x] Ensure immutability (no update method, only create)
- [x] Task 5: Create PolicyChange repository (AC: 2, 5)
  - [x] Create `api/repositories/policy_change_repository.py`
  - [x] Implement `create(change_data: dict) -> PolicyChange`
  - [x] Implement `get_by_id(change_id: UUID) -> Optional[PolicyChange]`
  - [x] Implement `get_by_source_id(source_id: UUID) -> List[PolicyChange]`
  - [x] Implement `get_latest_by_source_id(source_id: UUID) -> Optional[PolicyChange]`
  - [x] Implement `get_by_route(origin: str, destination: str, visa_type: str) -> List[PolicyChange]`
  - [x] Implement `get_by_date_range(start_date: datetime, end_date: datetime) -> List[PolicyChange]`
- [x] Task 6: Create RouteSubscription repository (AC: 2)
  - [x] Create `api/repositories/route_subscription_repository.py`
  - [x] Implement `create(route_data: dict) -> RouteSubscription`
  - [x] Implement `get_by_id(route_id: UUID) -> Optional[RouteSubscription]`
  - [x] Implement `list_all() -> List[RouteSubscription]`
  - [x] Implement `list_active() -> List[RouteSubscription]`
  - [x] Implement `get_by_route(origin: str, destination: str, visa_type: str) -> List[RouteSubscription]`
  - [x] Implement `update(route_id: UUID, update_data: dict) -> RouteSubscription`
  - [x] Implement `delete(route_id: UUID) -> bool`
  - [x] Implement `exists(origin: str, destination: str, visa_type: str, email: str) -> bool`
- [x] Task 7: Create helper functions for versioning and hashing (AC: 4, 5)
  - [x] Create `api/utils/versioning.py` (or add to existing utils)
  - [x] Implement `compare_hashes(old_hash: str, new_hash: str) -> bool`
  - [x] Implement helper to find latest version (delegate to repository)
  - [x] Add validation that PolicyVersion is never updated (immutability check)
- [x] Task 8: Add data validation (AC: 7)
  - [x] Add Pydantic validators for email format
  - [x] Add validators for country codes (2-character ISO codes)
  - [x] Add validators for visa types
  - [x] Add validators for fetch_type enum values
  - [x] Add validators for check_frequency enum values
  - [x] Add validators for URL format
  - [x] Add validators for hash length (64 characters)
- [x] Task 9: Create unit tests (AC: 6)
  - [x] Create `tests/unit/test_repositories/test_source_repository.py`
  - [x] Create `tests/unit/test_repositories/test_policy_version_repository.py`
  - [x] Create `tests/unit/test_repositories/test_policy_change_repository.py`
  - [x] Create `tests/unit/test_repositories/test_route_subscription_repository.py`
  - [x] Create `tests/unit/test_utils/test_hashing.py`
  - [x] Test CRUD operations for all repositories
  - [x] Test hashing function with various inputs
  - [x] Test versioning immutability
  - [x] Test hash comparison logic
  - [x] Test data validation rules

## Dev Notes

### Previous Story Insights
- Story 1.2 created SQLAlchemy database models and migration system
- Database connection and session factory are available in `api/database.py`
- All database models are defined in `api/models/db/`

### Data Models
[Source: architecture/data-models.md]

**Key Relationships:**
- Source (1) → (many) PolicyVersion
- Source (1) → (many) PolicyChange
- PolicyVersion (1) → (many) PolicyChange (as old/new versions)
- RouteSubscription matches Sources by country/visa_type (many-to-many, logical)

**Immutability Requirements:**
- PolicyVersion records are NEVER updated, only new versions created
- PolicyChange records are immutable (never updated)
- This ensures complete audit trail

### Backend Architecture
[Source: architecture/backend-architecture.md]

**Repository Pattern:**
- Repositories abstract database operations
- All database access goes through repositories
- Repositories use async SQLAlchemy sessions
- Services (created in later stories) will use repositories

**Data Access Layer:**
```python
# Example repository pattern
class SourceRepository:
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def create(self, source_data: dict) -> Source:
        source = Source(**source_data)
        self.session.add(source)
        await self.session.commit()
        await self.session.refresh(source)
        return source
```

### File Locations
[Source: architecture/unified-project-structure.md]

Files to create:
- `api/models/schemas/__init__.py` - Schema exports
- `api/models/schemas/source.py` - Source Pydantic schemas
- `api/models/schemas/policy_version.py` - PolicyVersion Pydantic schemas
- `api/models/schemas/policy_change.py` - PolicyChange Pydantic schemas
- `api/models/schemas/route_subscription.py` - RouteSubscription Pydantic schemas
- `api/repositories/__init__.py` - Repository exports
- `api/repositories/source_repository.py` - Source repository
- `api/repositories/policy_version_repository.py` - PolicyVersion repository
- `api/repositories/policy_change_repository.py` - PolicyChange repository
- `api/repositories/route_subscription_repository.py` - RouteSubscription repository
- `api/utils/hashing.py` - Hashing utilities
- `api/utils/versioning.py` - Versioning helpers (optional, can be in hashing.py)

### Coding Standards
[Source: architecture/coding-standards.md]

**Database Access:** Always use the Repository pattern. Never write raw SQL queries or access the database session directly from service/route layers.

**Type Hints:** All Python functions must have type hints. Use `typing` module for complex types, Pydantic models for request/response validation.

**Async/Await:** Use `async def` and `await` for all database operations. Never mix sync and async code without proper handling.

**Pydantic Models:** All API request/response bodies must use Pydantic models. Never use raw dictionaries or `dict` type hints.

**Error Handling:** Repository methods should raise exceptions, which will be handled by service layer (created in later stories).

### Testing Requirements
[Source: architecture/testing-strategy.md]

**Test Organization:**
- Unit tests in `tests/unit/test_repositories/`
- Unit tests for utilities in `tests/unit/test_utils/`

**Test Requirements:**
- Test all CRUD operations
- Test query methods (get_by_id, list, filter)
- Test immutability (PolicyVersion never updated)
- Test hashing function correctness
- Test data validation rules
- Use async test fixtures for database operations

### Technical Constraints
- SHA256 hashes must be exactly 64 characters (hex)
- PolicyVersion records are immutable (no update operations)
- All database operations must be async
- Pydantic validation required for all input/output
- Repository pattern must be followed (no direct database access)

## Testing

### Testing Standards
[Source: architecture/testing-strategy.md]

**Test File Location:** `tests/unit/test_repositories/` and `tests/unit/test_utils/`

**Test Standards:**
- Use pytest framework
- Test files follow `test_*.py` naming convention
- Use async test fixtures for database operations
- Mock database session for unit tests (or use test database)

**Testing Frameworks:**
- pytest 7.4+ with async support
- pytest-asyncio for async test support

**Specific Testing Requirements:**
- Test all repository CRUD operations
- Test hashing function with various inputs (empty string, long text, special characters)
- Test hash comparison logic
- Test PolicyVersion immutability (attempting update should fail or be prevented)
- Test data validation (invalid email, invalid country code, etc.)
- Test query methods (get_by_source_id, get_by_hash, etc.)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-27 | 1.0 | Initial story creation | Scrum Master |
| 2025-01-27 | 1.1 | Story implementation completed - all tasks and acceptance criteria met | Dev Agent (James) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (via Cursor)

### Debug Log References
N/A - No debug issues encountered during implementation

### Completion Notes List
- All tasks completed successfully
- Created comprehensive Pydantic schemas with validation for all models (Source, PolicyVersion, PolicyChange, RouteSubscription)
- Implemented hashing utility with SHA256 (64-character hex output) and hash comparison function
- Created all repositories following Repository pattern with async SQLAlchemy:
  - SourceRepository: Full CRUD operations
  - PolicyVersionRepository: Immutable (no update method), includes idempotency check
  - PolicyChangeRepository: Immutable, includes route-based and date range queries
  - RouteSubscriptionRepository: Full CRUD operations
- Created versioning utilities to enforce immutability requirements
- All data validation implemented in Pydantic schemas:
  - Email format validation (using EmailStr)
  - Country code validation (2-character, uppercase)
  - URL format validation
  - Hash length validation (64 characters)
  - Enum validation for fetch_type and check_frequency
- Comprehensive unit tests created:
  - Test fixtures using in-memory SQLite for fast tests
  - Tests for all repository CRUD operations
  - Tests for hashing utility with various inputs (empty string, long text, special characters, unicode)
  - Tests for hash comparison logic
  - Tests for data validation rules
  - Tests for immutability (PolicyVersion and PolicyChange have no update methods)
- Added aiosqlite to requirements.txt for in-memory SQLite testing
- All code follows async/await patterns and includes proper type hints

### File List
**Created Files:**
- `api/models/schemas/__init__.py` - Schema exports
- `api/models/schemas/source.py` - Source Pydantic schemas with validation
- `api/models/schemas/policy_version.py` - PolicyVersion Pydantic schemas
- `api/models/schemas/policy_change.py` - PolicyChange Pydantic schemas
- `api/models/schemas/route_subscription.py` - RouteSubscription Pydantic schemas
- `api/repositories/__init__.py` - Repository exports
- `api/repositories/source_repository.py` - Source repository with CRUD operations
- `api/repositories/policy_version_repository.py` - PolicyVersion repository (immutable)
- `api/repositories/policy_change_repository.py` - PolicyChange repository (immutable)
- `api/repositories/route_subscription_repository.py` - RouteSubscription repository with CRUD operations
- `api/utils/__init__.py` - Utils package init
- `api/utils/hashing.py` - SHA256 hashing utilities
- `api/utils/versioning.py` - Versioning helper functions
- `tests/conftest.py` - Pytest configuration and fixtures
- `tests/unit/test_repositories/test_source_repository.py` - Source repository tests
- `tests/unit/test_repositories/test_policy_version_repository.py` - PolicyVersion repository tests
- `tests/unit/test_repositories/test_policy_change_repository.py` - PolicyChange repository tests
- `tests/unit/test_repositories/test_route_subscription_repository.py` - RouteSubscription repository tests
- `tests/unit/test_utils/test_hashing.py` - Hashing utility tests

**Modified Files:**
- `requirements.txt` - Added aiosqlite for testing

**Created Directories:**
- `api/models/schemas/` - Pydantic schema package
- `api/repositories/` - Repository package
- `api/utils/` - Utility functions package
- `tests/unit/test_repositories/` - Repository test directory
- `tests/unit/test_utils/` - Utility test directory

## QA Results
_To be populated by QA Agent_

